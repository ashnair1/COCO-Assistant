{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"COCO-Assistant \u00b6 Note: Please install from source. I've encountered some issues with uploading to Pypi and will look into this when I have time. \u00b6 Helper for dealing with MS-COCO annotations. Overview \u00b6 The MS COCO annotation format along with the pycocotools library is quite popular among the computer vision community. Yet I for one found it difficult to play around with the annotations. Deleting a specific category, combining multiple mini datasets to generate a larger dataset, viewing distribution of classes in the annotation file are things I would like to do without writing a separate script for each scenario. The COCO Assistant is designed (or being designed) to assist with this problem. Please note that currently, the Assistant can only help out with object detection datasets . Any contributions and/or suggestions are welcome. Package features \u00b6 COCO-Assistant currently supports the following features: Merge datasets. Remove specfiic category from dataset. Generate annotations statistics - distribution of object areas and category distribution. Annotation visualiser for viewing the entire dataset. Documentation \u00b6 Project documentation can be found here Credits \u00b6 This package was created with the zillionare/cookiecutter-pypackage project template.","title":"Home"},{"location":"#coco-assistant","text":"","title":"COCO-Assistant"},{"location":"#note-please-install-from-source-ive-encountered-some-issues-with-uploading-to-pypi-and-will-look-into-this-when-i-have-time","text":"Helper for dealing with MS-COCO annotations.","title":"Note: Please install from source. I've encountered some issues with uploading to Pypi and will look into this when I have time."},{"location":"#overview","text":"The MS COCO annotation format along with the pycocotools library is quite popular among the computer vision community. Yet I for one found it difficult to play around with the annotations. Deleting a specific category, combining multiple mini datasets to generate a larger dataset, viewing distribution of classes in the annotation file are things I would like to do without writing a separate script for each scenario. The COCO Assistant is designed (or being designed) to assist with this problem. Please note that currently, the Assistant can only help out with object detection datasets . Any contributions and/or suggestions are welcome.","title":"Overview"},{"location":"#package-features","text":"COCO-Assistant currently supports the following features: Merge datasets. Remove specfiic category from dataset. Generate annotations statistics - distribution of object areas and category distribution. Annotation visualiser for viewing the entire dataset.","title":"Package features"},{"location":"#documentation","text":"Project documentation can be found here","title":"Documentation"},{"location":"#credits","text":"This package was created with the zillionare/cookiecutter-pypackage project template.","title":"Credits"},{"location":"CHANGELOG/","text":"History \u00b6 0.4.1 (2022-09-01) \u00b6 Changes : Drop coco-ash dependency. coco-ash was a personal fork of pycocotools and was created as a workaround for when poetry did not support git dependencies rooted in subdirectories. Since that is no longer the case, we're dropping the coco-ash dependency. 0.4.0 (2021-08-23) \u00b6 Changes : Drop Python 3.6 support Improved documentation Standardise docstring styles ( #32 ) Bugfixes : Bugfix for merge creating duplicated IDs by philipsgithub ( #50 ) 0.3.5 (2021-05-06) \u00b6 Changes : Replace os with pathlib for managing paths. Fixed bug in det2seg where small annotations were covered by larger annotations. Faster category removal by @xychen9459 ( #43 ). 0.3.4 (2021-03-14) \u00b6 Changes : Add support for merging datasets with different categories. Adding colour palette to segmasks is now optional. Ignore hidden files. 0.3.1 (2020-05-18) \u00b6 Bugfix : Fix for coco_stats by @Lplenka . Refer #15 0.3.0 (2020-04-19) \u00b6 Changes : combine has been renamed to merge . Add support for merging annotations only. Deprecations : Deprecate converters. This was motivated by two reasons: There are too many conversion formats. Trying to include even the most popular ones makes the project unwieldy. Better to use one of the readily available scripts online. Until now, the repository only supported TFRecord. Tensorflow is a large library and it does not make sense for it to be a project requirement when it's only used for a singular task of converting to TFRecord. 0.2.0 (2019-11-28) \u00b6 New features : Generate anchors from the dataset using K-means. Generate segmentation masks from dataset. Changes : Modified category removal to accept a list of categories as opposed to entering categories one after the other. 0.1.0 (2019-10-07) \u00b6 First release on PyPI. Supports the following functions: Merge datasets. Remove specfiic category from dataset. Generate annotations statistics - distribution of object areas and category distribution. Annotation visualiser for viewing the entire dataset. Converter for converting annotations to TFRecord format.","title":"Changelog"},{"location":"CHANGELOG/#history","text":"","title":"History"},{"location":"CHANGELOG/#041-2022-09-01","text":"Changes : Drop coco-ash dependency. coco-ash was a personal fork of pycocotools and was created as a workaround for when poetry did not support git dependencies rooted in subdirectories. Since that is no longer the case, we're dropping the coco-ash dependency.","title":"0.4.1 (2022-09-01)"},{"location":"CHANGELOG/#040-2021-08-23","text":"Changes : Drop Python 3.6 support Improved documentation Standardise docstring styles ( #32 ) Bugfixes : Bugfix for merge creating duplicated IDs by philipsgithub ( #50 )","title":"0.4.0 (2021-08-23)"},{"location":"CHANGELOG/#035-2021-05-06","text":"Changes : Replace os with pathlib for managing paths. Fixed bug in det2seg where small annotations were covered by larger annotations. Faster category removal by @xychen9459 ( #43 ).","title":"0.3.5 (2021-05-06)"},{"location":"CHANGELOG/#034-2021-03-14","text":"Changes : Add support for merging datasets with different categories. Adding colour palette to segmasks is now optional. Ignore hidden files.","title":"0.3.4 (2021-03-14)"},{"location":"CHANGELOG/#031-2020-05-18","text":"Bugfix : Fix for coco_stats by @Lplenka . Refer #15","title":"0.3.1 (2020-05-18)"},{"location":"CHANGELOG/#030-2020-04-19","text":"Changes : combine has been renamed to merge . Add support for merging annotations only. Deprecations : Deprecate converters. This was motivated by two reasons: There are too many conversion formats. Trying to include even the most popular ones makes the project unwieldy. Better to use one of the readily available scripts online. Until now, the repository only supported TFRecord. Tensorflow is a large library and it does not make sense for it to be a project requirement when it's only used for a singular task of converting to TFRecord.","title":"0.3.0 (2020-04-19)"},{"location":"CHANGELOG/#020-2019-11-28","text":"New features : Generate anchors from the dataset using K-means. Generate segmentation masks from dataset. Changes : Modified category removal to accept a list of categories as opposed to entering categories one after the other.","title":"0.2.0 (2019-11-28)"},{"location":"CHANGELOG/#010-2019-10-07","text":"First release on PyPI. Supports the following functions: Merge datasets. Remove specfiic category from dataset. Generate annotations statistics - distribution of object areas and category distribution. Annotation visualiser for viewing the entire dataset. Converter for converting annotations to TFRecord format.","title":"0.1.0 (2019-10-07)"},{"location":"CONTRIBUTING/","text":"Contributing Welcome contributors! Thank you for taking the time to contribute to this project. Your help is highly appreciated. The rules are pretty simple: Use Discussions for proposing major changes. This repo uses black & flake8 for style and formatting via pre-commit hooks. Kindly make sure you run it before submitting a PR. Refer Pull Request Process below. Pull Request Process \u00b6 Fork and clone the repo. Install poetry as specified here . and setup the dev environment as follows: poetry install -E dev -E doc -E test Running poetry shell will now put you in the dev environment. Setup pre-commit hooks by running pre-commit install in the dev environment. Now pre-commit will run on every git commit. Alternatively, you could just run pre-commit run --all-files after you're done. Confirm tests are passing by running tox . Submit PR.","title":"Contributing"},{"location":"CONTRIBUTING/#pull-request-process","text":"Fork and clone the repo. Install poetry as specified here . and setup the dev environment as follows: poetry install -E dev -E doc -E test Running poetry shell will now put you in the dev environment. Setup pre-commit hooks by running pre-commit install in the dev environment. Now pre-commit will run on every git commit. Alternatively, you could just run pre-commit run --all-files after you're done. Confirm tests are passing by running tox . Submit PR.","title":"Pull Request Process"},{"location":"installation/","text":"Installation Stable release \u00b6 To install COCO-Assistant, run this command in your terminal: $ pip install coco-assistant This is the preferred method to install COCO-Assistant, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process. From source \u00b6 The source for COCO-Assistant can be downloaded from the Github repo . You can either clone the public repository: $ git clone https://github.com/ashnair1/COCO-Assistant.git Or download the tarball : $ curl -OJL https://github.com/ashnair1/coco_assistant/tarball/master Once you have a copy of the source, you can install it by running make . cd COCO-Assistant/ pip install .","title":"Installation"},{"location":"installation/#stable-release","text":"To install COCO-Assistant, run this command in your terminal: $ pip install coco-assistant This is the preferred method to install COCO-Assistant, as it will always install the most recent stable release. If you don't have pip installed, this Python installation guide can guide you through the process.","title":"Stable release"},{"location":"installation/#from-source","text":"The source for COCO-Assistant can be downloaded from the Github repo . You can either clone the public repository: $ git clone https://github.com/ashnair1/COCO-Assistant.git Or download the tarball : $ curl -OJL https://github.com/ashnair1/coco_assistant/tarball/master Once you have a copy of the source, you can install it by running make . cd COCO-Assistant/ pip install .","title":"From source"},{"location":"summary/","text":"Home Installation Usage Contributing Changelog API Reference","title":"Summary"},{"location":"usage/","text":"Usage Requirements \u00b6 Your data directory should look as follows: Example: . \u251c\u2500\u2500 images \u2502 \u251c\u2500\u2500 train \u2502 \u251c\u2500\u2500 val | \u251c\u2500\u2500 test | \u251c\u2500\u2500 annotations \u2502 \u251c\u2500\u2500 train.json \u2502 \u251c\u2500\u2500 val.json \u2502 \u251c\u2500\u2500 test.json Usage is similar to how you would use pycocotools . from coco_assistant import COCO_Assistant # Specify image and annotation directories img_dir = os.path.join(os.getcwd(), 'images') ann_dir = os.path.join(os.getcwd(), 'annotations') # Create COCO_Assistant object cas = COCO_Assistant(img_dir, ann_dir) Package features \u00b6 1. Merge datasets \u00b6 The merge function allows you to merge multiple datasets. >>> cas = COCO_Assistant(img_dir, ann_dir) loading annotations into memory... Done (t=0.09s) creating index... index created! loading annotations into memory... Done (t=0.06s) creating index... index created! >>> cas.merge() Merging annotations 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00<00:00, 14.72it/s] The merged dataset (images and annotation) can be found in ./results/merged 2. Remove categories \u00b6 Removes a specific category from an annotation file. >>> cas = COCO_Assistant(img_dir, ann_dir) loading annotations into memory... Done (t=0.09s) creating index... index created! loading annotations into memory... Done (t=0.06s) creating index... index created! # In interactive mode >>> cas.remove_cat(interactive=True) ['tiny.json', 'tiny2.json'] Choose directory index (1:first, 2: second ..): 1 Categories present: ['building', 'vehicles'] Enter categories you wish to remove as a list: ['building'] Removing specified categories... # In non-interactive mode >>> cas.remove_cat(interactive=False, jc=\"tiny.json\", rcats=['building']) Removing specified categories... The modified annotation can be found in ./results/removal 3. Generate annotation statistics \u00b6 Generate countplot of instances per category that occur in the annotation files. >>> cas . ann_stats ( stat = \"area\" , arearng = [ 10 , 144 , 512 , 1e5 ], save = False ) Generate pie-chart that shows distribution of objects according to their size (as specified in areaRng). >>> cas . ann_stats ( stat = \"cat\" , arearng = None , show_count = False , save = False ) 4. Visualise annotations \u00b6 Couldn't pycocotools visualise annotations (via showAnns ) as well? Sure it could, but I required a way to freely view all the annotations of a particular dataset so here we are. >>> cas.visualise() Choose directory index (1:first, 2: second ..): ['tiny', 'tiny2'] 1 5. Generate segmentation masks \u00b6 The cas.get_segmasks() function allows you to create segmentation masks from your MS COCO object detection datasets. Please ensure your category ids start from 1. Similar to the Pascal VOC dataset, the mask values are their classes and a colour palette is applied (optional) to enable visualisation. The generated masks are stored in the ./results folder. Samples are shown below. Detection Segmentation SpaceNet iSAID","title":"Usage"},{"location":"usage/#requirements","text":"Your data directory should look as follows: Example: . \u251c\u2500\u2500 images \u2502 \u251c\u2500\u2500 train \u2502 \u251c\u2500\u2500 val | \u251c\u2500\u2500 test | \u251c\u2500\u2500 annotations \u2502 \u251c\u2500\u2500 train.json \u2502 \u251c\u2500\u2500 val.json \u2502 \u251c\u2500\u2500 test.json Usage is similar to how you would use pycocotools . from coco_assistant import COCO_Assistant # Specify image and annotation directories img_dir = os.path.join(os.getcwd(), 'images') ann_dir = os.path.join(os.getcwd(), 'annotations') # Create COCO_Assistant object cas = COCO_Assistant(img_dir, ann_dir)","title":"Requirements"},{"location":"usage/#package-features","text":"","title":"Package features"},{"location":"usage/#1-merge-datasets","text":"The merge function allows you to merge multiple datasets. >>> cas = COCO_Assistant(img_dir, ann_dir) loading annotations into memory... Done (t=0.09s) creating index... index created! loading annotations into memory... Done (t=0.06s) creating index... index created! >>> cas.merge() Merging annotations 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00<00:00, 14.72it/s] The merged dataset (images and annotation) can be found in ./results/merged","title":"1. Merge datasets"},{"location":"usage/#2-remove-categories","text":"Removes a specific category from an annotation file. >>> cas = COCO_Assistant(img_dir, ann_dir) loading annotations into memory... Done (t=0.09s) creating index... index created! loading annotations into memory... Done (t=0.06s) creating index... index created! # In interactive mode >>> cas.remove_cat(interactive=True) ['tiny.json', 'tiny2.json'] Choose directory index (1:first, 2: second ..): 1 Categories present: ['building', 'vehicles'] Enter categories you wish to remove as a list: ['building'] Removing specified categories... # In non-interactive mode >>> cas.remove_cat(interactive=False, jc=\"tiny.json\", rcats=['building']) Removing specified categories... The modified annotation can be found in ./results/removal","title":"2. Remove categories"},{"location":"usage/#3-generate-annotation-statistics","text":"Generate countplot of instances per category that occur in the annotation files. >>> cas . ann_stats ( stat = \"area\" , arearng = [ 10 , 144 , 512 , 1e5 ], save = False ) Generate pie-chart that shows distribution of objects according to their size (as specified in areaRng). >>> cas . ann_stats ( stat = \"cat\" , arearng = None , show_count = False , save = False )","title":"3. Generate annotation statistics"},{"location":"usage/#4-visualise-annotations","text":"Couldn't pycocotools visualise annotations (via showAnns ) as well? Sure it could, but I required a way to freely view all the annotations of a particular dataset so here we are. >>> cas.visualise() Choose directory index (1:first, 2: second ..): ['tiny', 'tiny2'] 1","title":"4. Visualise annotations"},{"location":"usage/#5-generate-segmentation-masks","text":"The cas.get_segmasks() function allows you to create segmentation masks from your MS COCO object detection datasets. Please ensure your category ids start from 1. Similar to the Pascal VOC dataset, the mask values are their classes and a colour palette is applied (optional) to enable visualisation. The generated masks are stored in the ./results folder. Samples are shown below. Detection Segmentation SpaceNet iSAID","title":"5. Generate segmentation masks"},{"location":"reference/SUMMARY/","text":"coco_assistant coco_assistant coco_stats coco_visualiser utils anchors det2seg misc remapper","title":"API Reference"},{"location":"reference/coco_assistant/","text":"coco_assistant.coco_assistant \u00b6 COCO_Assistant \u00b6 COCO_Assistant object Source code in coco_assistant/coco_assistant.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 class COCO_Assistant : \"\"\"COCO_Assistant object\"\"\" def __init__ ( self , img_dir , ann_dir ): \"\"\" Args: img_dir (str): Path to images folder. ann_dir (str): Path to images folder. \"\"\" self . img_dir = Path ( img_dir ) self . ann_dir = Path ( ann_dir ) self . res_dir = self . ann_dir . parent / \"results\" self . dh = utils . DirectoryHandler ( img_dir , ann_dir , self . res_dir ) # TODO: Add check for confirming these folders only contain .jpg and .json respectively logging . debug ( \"Number of image folders = %s \" , len ( self . dh . names )) logging . debug ( \"Number of annotation files = %s \" , len ( self . dh . names )) self . annfiles = [ COCO ( self . ann_dir / ( i + \".json\" )) for i in self . dh . names ] self . anndict = dict ( zip ( self . dh . names , self . annfiles )) self . ann_anchors = [] def merge ( self ): \"\"\" Merge multiple coco datasets \"\"\" resann_dir = self . dh . create ( \"merged/annotations\" ) cann = { \"images\" : [], \"annotations\" : [], \"info\" : None , \"licenses\" : None , \"categories\" : None } logging . debug ( \"Merging Annotations...\" ) dst_ann = resann_dir / \"merged.json\" print ( \"Merging annotations\" ) for j in tqdm ( self . dh . names ): cj = self . anndict [ j ] . dataset ind = self . dh . names . index ( j ) # Check if this is the 1st annotation. # If it is, continue else modify current annotation if ind == 0 : cann [ \"images\" ] = cann [ \"images\" ] + cj [ \"images\" ] cann [ \"annotations\" ] = cann [ \"annotations\" ] + cj [ \"annotations\" ] if \"info\" in list ( cj . keys ()): cann [ \"info\" ] = cj [ \"info\" ] if \"licenses\" in list ( cj . keys ()): cann [ \"licenses\" ] = cj [ \"licenses\" ] cann [ \"categories\" ] = sorted ( cj [ \"categories\" ], key = lambda i : i [ \"id\" ]) last_imid = cann [ \"images\" ][ - 1 ][ \"id\" ] last_annid = cann [ \"annotations\" ][ - 1 ][ \"id\" ] # If last imid or last_annid is a str, convert it to int if isinstance ( last_imid , str ) or isinstance ( last_annid , str ): logging . debug ( \"String Ids detected. Converting to int\" ) id_dict = {} # Change image id in images field for i , im in enumerate ( cann [ \"images\" ]): id_dict [ im [ \"id\" ]] = i im [ \"id\" ] = i # Change annotation id & image id in annotations field for i , im in enumerate ( cann [ \"annotations\" ]): im [ \"id\" ] = i if isinstance ( last_imid , str ): im [ \"image_id\" ] = id_dict [ im [ \"image_id\" ]] last_imid = max ( im [ \"id\" ] for im in cann [ \"images\" ]) last_annid = max ( ann [ \"id\" ] for ann in cann [ \"annotations\" ]) else : id_dict = {} # Change image id in images field for i , im in enumerate ( cj [ \"images\" ]): id_dict [ im [ \"id\" ]] = last_imid + i + 1 im [ \"id\" ] = last_imid + i + 1 # Change annotation and image ids in annotations field for i , ann in enumerate ( cj [ \"annotations\" ]): ann [ \"id\" ] = last_annid + i + 1 ann [ \"image_id\" ] = id_dict [ ann [ \"image_id\" ]] # Remap categories cmapper = utils . CatRemapper ( cann [ \"categories\" ], cj [ \"categories\" ]) cann [ \"categories\" ], cj [ \"annotations\" ] = cmapper . remap ( cj [ \"annotations\" ]) cann [ \"images\" ] = cann [ \"images\" ] + cj [ \"images\" ] cann [ \"annotations\" ] = cann [ \"annotations\" ] + cj [ \"annotations\" ] if \"info\" in list ( cj . keys ()): cann [ \"info\" ] = cj [ \"info\" ] if \"licenses\" in list ( cj . keys ()): cann [ \"licenses\" ] = cj [ \"licenses\" ] last_imid = cann [ \"images\" ][ - 1 ][ \"id\" ] last_annid = cann [ \"annotations\" ][ - 1 ][ \"id\" ] with open ( dst_ann , \"w\" ) as aw : json . dump ( cann , aw ) def remove_cat ( self , interactive = True , jc = None , rcats = None ): \"\"\" Remove categories. In interactive mode, you can input the json and the categories to be removed (as a list, see Usage for example) In non-interactive mode, you manually pass in json filename and categories to be removed. Note that jc and rcats cannot be None if run with interactive=False. Raises: AssertionError: if specified index exceeds number of datasets AssertionError: if rcats is not a list of strings AssertionError: if jc = rcats = None \"\"\" resrm_dir = self . dh . create ( \"removal\" ) if interactive : print ( self . dh . names ) print ( \"Choose directory index (1:first, 2: second ..)\" ) json_choice = input () try : json_choice = int ( json_choice ) - 1 except ValueError : sys . exit ( \"Please specify an index\" ) if json_choice > len ( self . dh . names ): raise AssertionError ( \"Index exceeds number of datasets\" ) # ann = self.annfiles[json_choice] name = self . dh . names [ json_choice ] json_name = name + \".json\" ann = self . anndict [ name ] print ( \" \\n Categories present:\" ) cats = [ i [ \"name\" ] for i in ann . cats . values ()] print ( cats ) self . rcats = [] print ( \" \\n Enter categories you wish to remove as a list:\" ) x = input () x = ast . literal_eval ( x ) if isinstance ( x , list ) is False : raise AssertionError ( \"Input must be a list of categories to be removed\" ) if all ( elem in cats for elem in x ): self . rcats = x else : print ( \"Incorrect entry.\" ) else : if jc is None or rcats is None : raise AssertionError ( \"Both json choice and rcats need to be provided in non-interactive mode\" ) # If passed, json_choice needs to be full path json_choice = Path ( jc ) # Full path name = json_choice . stem json_name = json_choice . name # abc ann = self . anndict [ name ] self . rcats = rcats print ( \"Removing specified categories...\" ) # Gives you a list of category ids of the categories to be removed catids_remove = ann . getCatIds ( catNms = self . rcats ) # Gives you a list of ids of annotations that contain those categories annids_remove = ann . getAnnIds ( catIds = catids_remove ) # Get keep category ids catids_keep = list ( set ( ann . getCatIds ()) - set ( catids_remove )) # Get keep annotation ids annids_keep = list ( set ( ann . getAnnIds ()) - set ( annids_remove )) with open ( self . ann_dir / json_name ) as it : x = json . load ( it ) del x [ \"categories\" ] x [ \"categories\" ] = ann . loadCats ( catids_keep ) del x [ \"annotations\" ] x [ \"annotations\" ] = ann . loadAnns ( annids_keep ) with open ( resrm_dir / json_name , \"w\" ) as oa : json . dump ( x , oa ) def ann_stats ( self , stat , arearng , show_count = False , save = False ): \"\"\"Display statistics. Args: stat (str): Type of statistic to be shown. Supports [\"area\", \"cat\"] arearng (list[float]): Area range list show_count (bool, optional): Shows category countplot if True. Defaults to False. save (bool, optional): Save stat plot to disk if True. Defaults to False. \"\"\" if stat == \"area\" : stats . pi_area_split ( self . anndict , areaRng = arearng , save = save ) elif stat == \"cat\" : stats . cat_count ( self . anndict , show_count = show_count , save = save ) def anchors ( self , n , fmt = \"rect\" , recompute = False ): \"\"\" Generate top N anchors !!! attention Experimental feature Args: n (int): Number of anchors fmt (str): Anchor type i.e. square or rectangular. Defaults to \"rect\". recompute (bool, optional): Recomputes the anchors if True. Defaults to False. \"\"\" if recompute or not self . ann_anchors : print ( \"Calculating anchors...\" ) names , anns = self . anndict . keys (), self . anndict . values () a = [ utils . generate_anchors ( j , n , fmt ) for j in anns ] self . ann_anchors = dict ( zip ( names , a )) else : print ( \"Loading pre-computed anchors\" ) print ( self . ann_anchors ) def get_segmasks ( self , palette = True ): \"\"\" Generate segmentation masks Args: palette (bool, optional): Create masks with color palette if True. Defaults to True. \"\"\" for name , ann in self . anndict . items (): output_dir = self . res_dir / \"segmasks\" / name utils . det2seg ( ann , output_dir , palette ) def visualise ( self ): \"\"\" Visualise annotations. \"\"\" print ( \"Choose directory index (1:first, 2: second ..):\" ) print ( self . dh . names ) dir_choice = input () try : dir_choice = int ( dir_choice ) - 1 except ValueError : sys . exit ( \"Please specify an index\" ) if dir_choice > len ( self . dh . names ): raise AssertionError ( \"Index exceeds number of datasets\" ) dir_choice = self . dh . names [ dir_choice ] ann = self . anndict [ dir_choice ] img_dir = self . img_dir / dir_choice cocovis . visualise_all ( ann , img_dir ) __init__ ( img_dir , ann_dir ) \u00b6 Parameters: Name Type Description Default img_dir str Path to images folder. required ann_dir str Path to images folder. required Source code in coco_assistant/coco_assistant.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def __init__ ( self , img_dir , ann_dir ): \"\"\" Args: img_dir (str): Path to images folder. ann_dir (str): Path to images folder. \"\"\" self . img_dir = Path ( img_dir ) self . ann_dir = Path ( ann_dir ) self . res_dir = self . ann_dir . parent / \"results\" self . dh = utils . DirectoryHandler ( img_dir , ann_dir , self . res_dir ) # TODO: Add check for confirming these folders only contain .jpg and .json respectively logging . debug ( \"Number of image folders = %s \" , len ( self . dh . names )) logging . debug ( \"Number of annotation files = %s \" , len ( self . dh . names )) self . annfiles = [ COCO ( self . ann_dir / ( i + \".json\" )) for i in self . dh . names ] self . anndict = dict ( zip ( self . dh . names , self . annfiles )) self . ann_anchors = [] anchors ( n , fmt = 'rect' , recompute = False ) \u00b6 Generate top N anchors Attention Experimental feature Parameters: Name Type Description Default n int Number of anchors required fmt str Anchor type i.e. square or rectangular. Defaults to \"rect\". 'rect' recompute bool Recomputes the anchors if True. Defaults to False. False Source code in coco_assistant/coco_assistant.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def anchors ( self , n , fmt = \"rect\" , recompute = False ): \"\"\" Generate top N anchors !!! attention Experimental feature Args: n (int): Number of anchors fmt (str): Anchor type i.e. square or rectangular. Defaults to \"rect\". recompute (bool, optional): Recomputes the anchors if True. Defaults to False. \"\"\" if recompute or not self . ann_anchors : print ( \"Calculating anchors...\" ) names , anns = self . anndict . keys (), self . anndict . values () a = [ utils . generate_anchors ( j , n , fmt ) for j in anns ] self . ann_anchors = dict ( zip ( names , a )) else : print ( \"Loading pre-computed anchors\" ) print ( self . ann_anchors ) ann_stats ( stat , arearng , show_count = False , save = False ) \u00b6 Display statistics. Parameters: Name Type Description Default stat str Type of statistic to be shown. Supports [\"area\", \"cat\"] required arearng list [ float ] Area range list required show_count bool Shows category countplot if True. Defaults to False. False save bool Save stat plot to disk if True. Defaults to False. False Source code in coco_assistant/coco_assistant.py 231 232 233 234 235 236 237 238 239 240 241 242 243 def ann_stats ( self , stat , arearng , show_count = False , save = False ): \"\"\"Display statistics. Args: stat (str): Type of statistic to be shown. Supports [\"area\", \"cat\"] arearng (list[float]): Area range list show_count (bool, optional): Shows category countplot if True. Defaults to False. save (bool, optional): Save stat plot to disk if True. Defaults to False. \"\"\" if stat == \"area\" : stats . pi_area_split ( self . anndict , areaRng = arearng , save = save ) elif stat == \"cat\" : stats . cat_count ( self . anndict , show_count = show_count , save = save ) get_segmasks ( palette = True ) \u00b6 Generate segmentation masks Parameters: Name Type Description Default palette bool Create masks with color palette if True. Defaults to True. True Source code in coco_assistant/coco_assistant.py 267 268 269 270 271 272 273 274 275 276 def get_segmasks ( self , palette = True ): \"\"\" Generate segmentation masks Args: palette (bool, optional): Create masks with color palette if True. Defaults to True. \"\"\" for name , ann in self . anndict . items (): output_dir = self . res_dir / \"segmasks\" / name utils . det2seg ( ann , output_dir , palette ) merge () \u00b6 Merge multiple coco datasets Source code in coco_assistant/coco_assistant.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def merge ( self ): \"\"\" Merge multiple coco datasets \"\"\" resann_dir = self . dh . create ( \"merged/annotations\" ) cann = { \"images\" : [], \"annotations\" : [], \"info\" : None , \"licenses\" : None , \"categories\" : None } logging . debug ( \"Merging Annotations...\" ) dst_ann = resann_dir / \"merged.json\" print ( \"Merging annotations\" ) for j in tqdm ( self . dh . names ): cj = self . anndict [ j ] . dataset ind = self . dh . names . index ( j ) # Check if this is the 1st annotation. # If it is, continue else modify current annotation if ind == 0 : cann [ \"images\" ] = cann [ \"images\" ] + cj [ \"images\" ] cann [ \"annotations\" ] = cann [ \"annotations\" ] + cj [ \"annotations\" ] if \"info\" in list ( cj . keys ()): cann [ \"info\" ] = cj [ \"info\" ] if \"licenses\" in list ( cj . keys ()): cann [ \"licenses\" ] = cj [ \"licenses\" ] cann [ \"categories\" ] = sorted ( cj [ \"categories\" ], key = lambda i : i [ \"id\" ]) last_imid = cann [ \"images\" ][ - 1 ][ \"id\" ] last_annid = cann [ \"annotations\" ][ - 1 ][ \"id\" ] # If last imid or last_annid is a str, convert it to int if isinstance ( last_imid , str ) or isinstance ( last_annid , str ): logging . debug ( \"String Ids detected. Converting to int\" ) id_dict = {} # Change image id in images field for i , im in enumerate ( cann [ \"images\" ]): id_dict [ im [ \"id\" ]] = i im [ \"id\" ] = i # Change annotation id & image id in annotations field for i , im in enumerate ( cann [ \"annotations\" ]): im [ \"id\" ] = i if isinstance ( last_imid , str ): im [ \"image_id\" ] = id_dict [ im [ \"image_id\" ]] last_imid = max ( im [ \"id\" ] for im in cann [ \"images\" ]) last_annid = max ( ann [ \"id\" ] for ann in cann [ \"annotations\" ]) else : id_dict = {} # Change image id in images field for i , im in enumerate ( cj [ \"images\" ]): id_dict [ im [ \"id\" ]] = last_imid + i + 1 im [ \"id\" ] = last_imid + i + 1 # Change annotation and image ids in annotations field for i , ann in enumerate ( cj [ \"annotations\" ]): ann [ \"id\" ] = last_annid + i + 1 ann [ \"image_id\" ] = id_dict [ ann [ \"image_id\" ]] # Remap categories cmapper = utils . CatRemapper ( cann [ \"categories\" ], cj [ \"categories\" ]) cann [ \"categories\" ], cj [ \"annotations\" ] = cmapper . remap ( cj [ \"annotations\" ]) cann [ \"images\" ] = cann [ \"images\" ] + cj [ \"images\" ] cann [ \"annotations\" ] = cann [ \"annotations\" ] + cj [ \"annotations\" ] if \"info\" in list ( cj . keys ()): cann [ \"info\" ] = cj [ \"info\" ] if \"licenses\" in list ( cj . keys ()): cann [ \"licenses\" ] = cj [ \"licenses\" ] last_imid = cann [ \"images\" ][ - 1 ][ \"id\" ] last_annid = cann [ \"annotations\" ][ - 1 ][ \"id\" ] with open ( dst_ann , \"w\" ) as aw : json . dump ( cann , aw ) remove_cat ( interactive = True , jc = None , rcats = None ) \u00b6 Remove categories. In interactive mode, you can input the json and the categories to be removed (as a list, see Usage for example) In non-interactive mode, you manually pass in json filename and categories to be removed. Note that jc and rcats cannot be None if run with interactive=False. Raises: Type Description AssertionError if specified index exceeds number of datasets AssertionError if rcats is not a list of strings AssertionError if jc = rcats = None Source code in coco_assistant/coco_assistant.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def remove_cat ( self , interactive = True , jc = None , rcats = None ): \"\"\" Remove categories. In interactive mode, you can input the json and the categories to be removed (as a list, see Usage for example) In non-interactive mode, you manually pass in json filename and categories to be removed. Note that jc and rcats cannot be None if run with interactive=False. Raises: AssertionError: if specified index exceeds number of datasets AssertionError: if rcats is not a list of strings AssertionError: if jc = rcats = None \"\"\" resrm_dir = self . dh . create ( \"removal\" ) if interactive : print ( self . dh . names ) print ( \"Choose directory index (1:first, 2: second ..)\" ) json_choice = input () try : json_choice = int ( json_choice ) - 1 except ValueError : sys . exit ( \"Please specify an index\" ) if json_choice > len ( self . dh . names ): raise AssertionError ( \"Index exceeds number of datasets\" ) # ann = self.annfiles[json_choice] name = self . dh . names [ json_choice ] json_name = name + \".json\" ann = self . anndict [ name ] print ( \" \\n Categories present:\" ) cats = [ i [ \"name\" ] for i in ann . cats . values ()] print ( cats ) self . rcats = [] print ( \" \\n Enter categories you wish to remove as a list:\" ) x = input () x = ast . literal_eval ( x ) if isinstance ( x , list ) is False : raise AssertionError ( \"Input must be a list of categories to be removed\" ) if all ( elem in cats for elem in x ): self . rcats = x else : print ( \"Incorrect entry.\" ) else : if jc is None or rcats is None : raise AssertionError ( \"Both json choice and rcats need to be provided in non-interactive mode\" ) # If passed, json_choice needs to be full path json_choice = Path ( jc ) # Full path name = json_choice . stem json_name = json_choice . name # abc ann = self . anndict [ name ] self . rcats = rcats print ( \"Removing specified categories...\" ) # Gives you a list of category ids of the categories to be removed catids_remove = ann . getCatIds ( catNms = self . rcats ) # Gives you a list of ids of annotations that contain those categories annids_remove = ann . getAnnIds ( catIds = catids_remove ) # Get keep category ids catids_keep = list ( set ( ann . getCatIds ()) - set ( catids_remove )) # Get keep annotation ids annids_keep = list ( set ( ann . getAnnIds ()) - set ( annids_remove )) with open ( self . ann_dir / json_name ) as it : x = json . load ( it ) del x [ \"categories\" ] x [ \"categories\" ] = ann . loadCats ( catids_keep ) del x [ \"annotations\" ] x [ \"annotations\" ] = ann . loadAnns ( annids_keep ) with open ( resrm_dir / json_name , \"w\" ) as oa : json . dump ( x , oa ) visualise () \u00b6 Visualise annotations. Source code in coco_assistant/coco_assistant.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def visualise ( self ): \"\"\" Visualise annotations. \"\"\" print ( \"Choose directory index (1:first, 2: second ..):\" ) print ( self . dh . names ) dir_choice = input () try : dir_choice = int ( dir_choice ) - 1 except ValueError : sys . exit ( \"Please specify an index\" ) if dir_choice > len ( self . dh . names ): raise AssertionError ( \"Index exceeds number of datasets\" ) dir_choice = self . dh . names [ dir_choice ] ann = self . anndict [ dir_choice ] img_dir = self . img_dir / dir_choice cocovis . visualise_all ( ann , img_dir )","title":"Coco assistant"},{"location":"reference/coco_assistant/#coco_assistant.coco_assistant","text":"","title":"coco_assistant"},{"location":"reference/coco_assistant/#coco_assistant.coco_assistant.COCO_Assistant","text":"COCO_Assistant object Source code in coco_assistant/coco_assistant.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 class COCO_Assistant : \"\"\"COCO_Assistant object\"\"\" def __init__ ( self , img_dir , ann_dir ): \"\"\" Args: img_dir (str): Path to images folder. ann_dir (str): Path to images folder. \"\"\" self . img_dir = Path ( img_dir ) self . ann_dir = Path ( ann_dir ) self . res_dir = self . ann_dir . parent / \"results\" self . dh = utils . DirectoryHandler ( img_dir , ann_dir , self . res_dir ) # TODO: Add check for confirming these folders only contain .jpg and .json respectively logging . debug ( \"Number of image folders = %s \" , len ( self . dh . names )) logging . debug ( \"Number of annotation files = %s \" , len ( self . dh . names )) self . annfiles = [ COCO ( self . ann_dir / ( i + \".json\" )) for i in self . dh . names ] self . anndict = dict ( zip ( self . dh . names , self . annfiles )) self . ann_anchors = [] def merge ( self ): \"\"\" Merge multiple coco datasets \"\"\" resann_dir = self . dh . create ( \"merged/annotations\" ) cann = { \"images\" : [], \"annotations\" : [], \"info\" : None , \"licenses\" : None , \"categories\" : None } logging . debug ( \"Merging Annotations...\" ) dst_ann = resann_dir / \"merged.json\" print ( \"Merging annotations\" ) for j in tqdm ( self . dh . names ): cj = self . anndict [ j ] . dataset ind = self . dh . names . index ( j ) # Check if this is the 1st annotation. # If it is, continue else modify current annotation if ind == 0 : cann [ \"images\" ] = cann [ \"images\" ] + cj [ \"images\" ] cann [ \"annotations\" ] = cann [ \"annotations\" ] + cj [ \"annotations\" ] if \"info\" in list ( cj . keys ()): cann [ \"info\" ] = cj [ \"info\" ] if \"licenses\" in list ( cj . keys ()): cann [ \"licenses\" ] = cj [ \"licenses\" ] cann [ \"categories\" ] = sorted ( cj [ \"categories\" ], key = lambda i : i [ \"id\" ]) last_imid = cann [ \"images\" ][ - 1 ][ \"id\" ] last_annid = cann [ \"annotations\" ][ - 1 ][ \"id\" ] # If last imid or last_annid is a str, convert it to int if isinstance ( last_imid , str ) or isinstance ( last_annid , str ): logging . debug ( \"String Ids detected. Converting to int\" ) id_dict = {} # Change image id in images field for i , im in enumerate ( cann [ \"images\" ]): id_dict [ im [ \"id\" ]] = i im [ \"id\" ] = i # Change annotation id & image id in annotations field for i , im in enumerate ( cann [ \"annotations\" ]): im [ \"id\" ] = i if isinstance ( last_imid , str ): im [ \"image_id\" ] = id_dict [ im [ \"image_id\" ]] last_imid = max ( im [ \"id\" ] for im in cann [ \"images\" ]) last_annid = max ( ann [ \"id\" ] for ann in cann [ \"annotations\" ]) else : id_dict = {} # Change image id in images field for i , im in enumerate ( cj [ \"images\" ]): id_dict [ im [ \"id\" ]] = last_imid + i + 1 im [ \"id\" ] = last_imid + i + 1 # Change annotation and image ids in annotations field for i , ann in enumerate ( cj [ \"annotations\" ]): ann [ \"id\" ] = last_annid + i + 1 ann [ \"image_id\" ] = id_dict [ ann [ \"image_id\" ]] # Remap categories cmapper = utils . CatRemapper ( cann [ \"categories\" ], cj [ \"categories\" ]) cann [ \"categories\" ], cj [ \"annotations\" ] = cmapper . remap ( cj [ \"annotations\" ]) cann [ \"images\" ] = cann [ \"images\" ] + cj [ \"images\" ] cann [ \"annotations\" ] = cann [ \"annotations\" ] + cj [ \"annotations\" ] if \"info\" in list ( cj . keys ()): cann [ \"info\" ] = cj [ \"info\" ] if \"licenses\" in list ( cj . keys ()): cann [ \"licenses\" ] = cj [ \"licenses\" ] last_imid = cann [ \"images\" ][ - 1 ][ \"id\" ] last_annid = cann [ \"annotations\" ][ - 1 ][ \"id\" ] with open ( dst_ann , \"w\" ) as aw : json . dump ( cann , aw ) def remove_cat ( self , interactive = True , jc = None , rcats = None ): \"\"\" Remove categories. In interactive mode, you can input the json and the categories to be removed (as a list, see Usage for example) In non-interactive mode, you manually pass in json filename and categories to be removed. Note that jc and rcats cannot be None if run with interactive=False. Raises: AssertionError: if specified index exceeds number of datasets AssertionError: if rcats is not a list of strings AssertionError: if jc = rcats = None \"\"\" resrm_dir = self . dh . create ( \"removal\" ) if interactive : print ( self . dh . names ) print ( \"Choose directory index (1:first, 2: second ..)\" ) json_choice = input () try : json_choice = int ( json_choice ) - 1 except ValueError : sys . exit ( \"Please specify an index\" ) if json_choice > len ( self . dh . names ): raise AssertionError ( \"Index exceeds number of datasets\" ) # ann = self.annfiles[json_choice] name = self . dh . names [ json_choice ] json_name = name + \".json\" ann = self . anndict [ name ] print ( \" \\n Categories present:\" ) cats = [ i [ \"name\" ] for i in ann . cats . values ()] print ( cats ) self . rcats = [] print ( \" \\n Enter categories you wish to remove as a list:\" ) x = input () x = ast . literal_eval ( x ) if isinstance ( x , list ) is False : raise AssertionError ( \"Input must be a list of categories to be removed\" ) if all ( elem in cats for elem in x ): self . rcats = x else : print ( \"Incorrect entry.\" ) else : if jc is None or rcats is None : raise AssertionError ( \"Both json choice and rcats need to be provided in non-interactive mode\" ) # If passed, json_choice needs to be full path json_choice = Path ( jc ) # Full path name = json_choice . stem json_name = json_choice . name # abc ann = self . anndict [ name ] self . rcats = rcats print ( \"Removing specified categories...\" ) # Gives you a list of category ids of the categories to be removed catids_remove = ann . getCatIds ( catNms = self . rcats ) # Gives you a list of ids of annotations that contain those categories annids_remove = ann . getAnnIds ( catIds = catids_remove ) # Get keep category ids catids_keep = list ( set ( ann . getCatIds ()) - set ( catids_remove )) # Get keep annotation ids annids_keep = list ( set ( ann . getAnnIds ()) - set ( annids_remove )) with open ( self . ann_dir / json_name ) as it : x = json . load ( it ) del x [ \"categories\" ] x [ \"categories\" ] = ann . loadCats ( catids_keep ) del x [ \"annotations\" ] x [ \"annotations\" ] = ann . loadAnns ( annids_keep ) with open ( resrm_dir / json_name , \"w\" ) as oa : json . dump ( x , oa ) def ann_stats ( self , stat , arearng , show_count = False , save = False ): \"\"\"Display statistics. Args: stat (str): Type of statistic to be shown. Supports [\"area\", \"cat\"] arearng (list[float]): Area range list show_count (bool, optional): Shows category countplot if True. Defaults to False. save (bool, optional): Save stat plot to disk if True. Defaults to False. \"\"\" if stat == \"area\" : stats . pi_area_split ( self . anndict , areaRng = arearng , save = save ) elif stat == \"cat\" : stats . cat_count ( self . anndict , show_count = show_count , save = save ) def anchors ( self , n , fmt = \"rect\" , recompute = False ): \"\"\" Generate top N anchors !!! attention Experimental feature Args: n (int): Number of anchors fmt (str): Anchor type i.e. square or rectangular. Defaults to \"rect\". recompute (bool, optional): Recomputes the anchors if True. Defaults to False. \"\"\" if recompute or not self . ann_anchors : print ( \"Calculating anchors...\" ) names , anns = self . anndict . keys (), self . anndict . values () a = [ utils . generate_anchors ( j , n , fmt ) for j in anns ] self . ann_anchors = dict ( zip ( names , a )) else : print ( \"Loading pre-computed anchors\" ) print ( self . ann_anchors ) def get_segmasks ( self , palette = True ): \"\"\" Generate segmentation masks Args: palette (bool, optional): Create masks with color palette if True. Defaults to True. \"\"\" for name , ann in self . anndict . items (): output_dir = self . res_dir / \"segmasks\" / name utils . det2seg ( ann , output_dir , palette ) def visualise ( self ): \"\"\" Visualise annotations. \"\"\" print ( \"Choose directory index (1:first, 2: second ..):\" ) print ( self . dh . names ) dir_choice = input () try : dir_choice = int ( dir_choice ) - 1 except ValueError : sys . exit ( \"Please specify an index\" ) if dir_choice > len ( self . dh . names ): raise AssertionError ( \"Index exceeds number of datasets\" ) dir_choice = self . dh . names [ dir_choice ] ann = self . anndict [ dir_choice ] img_dir = self . img_dir / dir_choice cocovis . visualise_all ( ann , img_dir )","title":"COCO_Assistant"},{"location":"reference/coco_assistant/#coco_assistant.coco_assistant.COCO_Assistant.__init__","text":"Parameters: Name Type Description Default img_dir str Path to images folder. required ann_dir str Path to images folder. required Source code in coco_assistant/coco_assistant.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 def __init__ ( self , img_dir , ann_dir ): \"\"\" Args: img_dir (str): Path to images folder. ann_dir (str): Path to images folder. \"\"\" self . img_dir = Path ( img_dir ) self . ann_dir = Path ( ann_dir ) self . res_dir = self . ann_dir . parent / \"results\" self . dh = utils . DirectoryHandler ( img_dir , ann_dir , self . res_dir ) # TODO: Add check for confirming these folders only contain .jpg and .json respectively logging . debug ( \"Number of image folders = %s \" , len ( self . dh . names )) logging . debug ( \"Number of annotation files = %s \" , len ( self . dh . names )) self . annfiles = [ COCO ( self . ann_dir / ( i + \".json\" )) for i in self . dh . names ] self . anndict = dict ( zip ( self . dh . names , self . annfiles )) self . ann_anchors = []","title":"__init__()"},{"location":"reference/coco_assistant/#coco_assistant.coco_assistant.COCO_Assistant.anchors","text":"Generate top N anchors Attention Experimental feature Parameters: Name Type Description Default n int Number of anchors required fmt str Anchor type i.e. square or rectangular. Defaults to \"rect\". 'rect' recompute bool Recomputes the anchors if True. Defaults to False. False Source code in coco_assistant/coco_assistant.py 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 def anchors ( self , n , fmt = \"rect\" , recompute = False ): \"\"\" Generate top N anchors !!! attention Experimental feature Args: n (int): Number of anchors fmt (str): Anchor type i.e. square or rectangular. Defaults to \"rect\". recompute (bool, optional): Recomputes the anchors if True. Defaults to False. \"\"\" if recompute or not self . ann_anchors : print ( \"Calculating anchors...\" ) names , anns = self . anndict . keys (), self . anndict . values () a = [ utils . generate_anchors ( j , n , fmt ) for j in anns ] self . ann_anchors = dict ( zip ( names , a )) else : print ( \"Loading pre-computed anchors\" ) print ( self . ann_anchors )","title":"anchors()"},{"location":"reference/coco_assistant/#coco_assistant.coco_assistant.COCO_Assistant.ann_stats","text":"Display statistics. Parameters: Name Type Description Default stat str Type of statistic to be shown. Supports [\"area\", \"cat\"] required arearng list [ float ] Area range list required show_count bool Shows category countplot if True. Defaults to False. False save bool Save stat plot to disk if True. Defaults to False. False Source code in coco_assistant/coco_assistant.py 231 232 233 234 235 236 237 238 239 240 241 242 243 def ann_stats ( self , stat , arearng , show_count = False , save = False ): \"\"\"Display statistics. Args: stat (str): Type of statistic to be shown. Supports [\"area\", \"cat\"] arearng (list[float]): Area range list show_count (bool, optional): Shows category countplot if True. Defaults to False. save (bool, optional): Save stat plot to disk if True. Defaults to False. \"\"\" if stat == \"area\" : stats . pi_area_split ( self . anndict , areaRng = arearng , save = save ) elif stat == \"cat\" : stats . cat_count ( self . anndict , show_count = show_count , save = save )","title":"ann_stats()"},{"location":"reference/coco_assistant/#coco_assistant.coco_assistant.COCO_Assistant.get_segmasks","text":"Generate segmentation masks Parameters: Name Type Description Default palette bool Create masks with color palette if True. Defaults to True. True Source code in coco_assistant/coco_assistant.py 267 268 269 270 271 272 273 274 275 276 def get_segmasks ( self , palette = True ): \"\"\" Generate segmentation masks Args: palette (bool, optional): Create masks with color palette if True. Defaults to True. \"\"\" for name , ann in self . anndict . items (): output_dir = self . res_dir / \"segmasks\" / name utils . det2seg ( ann , output_dir , palette )","title":"get_segmasks()"},{"location":"reference/coco_assistant/#coco_assistant.coco_assistant.COCO_Assistant.merge","text":"Merge multiple coco datasets Source code in coco_assistant/coco_assistant.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 def merge ( self ): \"\"\" Merge multiple coco datasets \"\"\" resann_dir = self . dh . create ( \"merged/annotations\" ) cann = { \"images\" : [], \"annotations\" : [], \"info\" : None , \"licenses\" : None , \"categories\" : None } logging . debug ( \"Merging Annotations...\" ) dst_ann = resann_dir / \"merged.json\" print ( \"Merging annotations\" ) for j in tqdm ( self . dh . names ): cj = self . anndict [ j ] . dataset ind = self . dh . names . index ( j ) # Check if this is the 1st annotation. # If it is, continue else modify current annotation if ind == 0 : cann [ \"images\" ] = cann [ \"images\" ] + cj [ \"images\" ] cann [ \"annotations\" ] = cann [ \"annotations\" ] + cj [ \"annotations\" ] if \"info\" in list ( cj . keys ()): cann [ \"info\" ] = cj [ \"info\" ] if \"licenses\" in list ( cj . keys ()): cann [ \"licenses\" ] = cj [ \"licenses\" ] cann [ \"categories\" ] = sorted ( cj [ \"categories\" ], key = lambda i : i [ \"id\" ]) last_imid = cann [ \"images\" ][ - 1 ][ \"id\" ] last_annid = cann [ \"annotations\" ][ - 1 ][ \"id\" ] # If last imid or last_annid is a str, convert it to int if isinstance ( last_imid , str ) or isinstance ( last_annid , str ): logging . debug ( \"String Ids detected. Converting to int\" ) id_dict = {} # Change image id in images field for i , im in enumerate ( cann [ \"images\" ]): id_dict [ im [ \"id\" ]] = i im [ \"id\" ] = i # Change annotation id & image id in annotations field for i , im in enumerate ( cann [ \"annotations\" ]): im [ \"id\" ] = i if isinstance ( last_imid , str ): im [ \"image_id\" ] = id_dict [ im [ \"image_id\" ]] last_imid = max ( im [ \"id\" ] for im in cann [ \"images\" ]) last_annid = max ( ann [ \"id\" ] for ann in cann [ \"annotations\" ]) else : id_dict = {} # Change image id in images field for i , im in enumerate ( cj [ \"images\" ]): id_dict [ im [ \"id\" ]] = last_imid + i + 1 im [ \"id\" ] = last_imid + i + 1 # Change annotation and image ids in annotations field for i , ann in enumerate ( cj [ \"annotations\" ]): ann [ \"id\" ] = last_annid + i + 1 ann [ \"image_id\" ] = id_dict [ ann [ \"image_id\" ]] # Remap categories cmapper = utils . CatRemapper ( cann [ \"categories\" ], cj [ \"categories\" ]) cann [ \"categories\" ], cj [ \"annotations\" ] = cmapper . remap ( cj [ \"annotations\" ]) cann [ \"images\" ] = cann [ \"images\" ] + cj [ \"images\" ] cann [ \"annotations\" ] = cann [ \"annotations\" ] + cj [ \"annotations\" ] if \"info\" in list ( cj . keys ()): cann [ \"info\" ] = cj [ \"info\" ] if \"licenses\" in list ( cj . keys ()): cann [ \"licenses\" ] = cj [ \"licenses\" ] last_imid = cann [ \"images\" ][ - 1 ][ \"id\" ] last_annid = cann [ \"annotations\" ][ - 1 ][ \"id\" ] with open ( dst_ann , \"w\" ) as aw : json . dump ( cann , aw )","title":"merge()"},{"location":"reference/coco_assistant/#coco_assistant.coco_assistant.COCO_Assistant.remove_cat","text":"Remove categories. In interactive mode, you can input the json and the categories to be removed (as a list, see Usage for example) In non-interactive mode, you manually pass in json filename and categories to be removed. Note that jc and rcats cannot be None if run with interactive=False. Raises: Type Description AssertionError if specified index exceeds number of datasets AssertionError if rcats is not a list of strings AssertionError if jc = rcats = None Source code in coco_assistant/coco_assistant.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 def remove_cat ( self , interactive = True , jc = None , rcats = None ): \"\"\" Remove categories. In interactive mode, you can input the json and the categories to be removed (as a list, see Usage for example) In non-interactive mode, you manually pass in json filename and categories to be removed. Note that jc and rcats cannot be None if run with interactive=False. Raises: AssertionError: if specified index exceeds number of datasets AssertionError: if rcats is not a list of strings AssertionError: if jc = rcats = None \"\"\" resrm_dir = self . dh . create ( \"removal\" ) if interactive : print ( self . dh . names ) print ( \"Choose directory index (1:first, 2: second ..)\" ) json_choice = input () try : json_choice = int ( json_choice ) - 1 except ValueError : sys . exit ( \"Please specify an index\" ) if json_choice > len ( self . dh . names ): raise AssertionError ( \"Index exceeds number of datasets\" ) # ann = self.annfiles[json_choice] name = self . dh . names [ json_choice ] json_name = name + \".json\" ann = self . anndict [ name ] print ( \" \\n Categories present:\" ) cats = [ i [ \"name\" ] for i in ann . cats . values ()] print ( cats ) self . rcats = [] print ( \" \\n Enter categories you wish to remove as a list:\" ) x = input () x = ast . literal_eval ( x ) if isinstance ( x , list ) is False : raise AssertionError ( \"Input must be a list of categories to be removed\" ) if all ( elem in cats for elem in x ): self . rcats = x else : print ( \"Incorrect entry.\" ) else : if jc is None or rcats is None : raise AssertionError ( \"Both json choice and rcats need to be provided in non-interactive mode\" ) # If passed, json_choice needs to be full path json_choice = Path ( jc ) # Full path name = json_choice . stem json_name = json_choice . name # abc ann = self . anndict [ name ] self . rcats = rcats print ( \"Removing specified categories...\" ) # Gives you a list of category ids of the categories to be removed catids_remove = ann . getCatIds ( catNms = self . rcats ) # Gives you a list of ids of annotations that contain those categories annids_remove = ann . getAnnIds ( catIds = catids_remove ) # Get keep category ids catids_keep = list ( set ( ann . getCatIds ()) - set ( catids_remove )) # Get keep annotation ids annids_keep = list ( set ( ann . getAnnIds ()) - set ( annids_remove )) with open ( self . ann_dir / json_name ) as it : x = json . load ( it ) del x [ \"categories\" ] x [ \"categories\" ] = ann . loadCats ( catids_keep ) del x [ \"annotations\" ] x [ \"annotations\" ] = ann . loadAnns ( annids_keep ) with open ( resrm_dir / json_name , \"w\" ) as oa : json . dump ( x , oa )","title":"remove_cat()"},{"location":"reference/coco_assistant/#coco_assistant.coco_assistant.COCO_Assistant.visualise","text":"Visualise annotations. Source code in coco_assistant/coco_assistant.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def visualise ( self ): \"\"\" Visualise annotations. \"\"\" print ( \"Choose directory index (1:first, 2: second ..):\" ) print ( self . dh . names ) dir_choice = input () try : dir_choice = int ( dir_choice ) - 1 except ValueError : sys . exit ( \"Please specify an index\" ) if dir_choice > len ( self . dh . names ): raise AssertionError ( \"Index exceeds number of datasets\" ) dir_choice = self . dh . names [ dir_choice ] ann = self . anndict [ dir_choice ] img_dir = self . img_dir / dir_choice cocovis . visualise_all ( ann , img_dir )","title":"visualise()"},{"location":"reference/coco_stats/","text":"coco_assistant.coco_stats \u00b6","title":"Coco stats"},{"location":"reference/coco_stats/#coco_assistant.coco_stats","text":"","title":"coco_stats"},{"location":"reference/coco_visualiser/","text":"coco_assistant.coco_visualiser \u00b6 get_imgid_dict ( ann ) \u00b6 Returns a dictionary with img ids as keys and img filenames as values Source code in coco_assistant/coco_visualiser.py 118 119 120 121 122 def get_imgid_dict ( ann ): \"\"\" Returns a dictionary with img ids as keys and img filenames as values \"\"\" return { item [ 1 ][ \"file_name\" ]: item [ 0 ] for item in ann . imgs . items ()}","title":"Coco visualiser"},{"location":"reference/coco_visualiser/#coco_assistant.coco_visualiser","text":"","title":"coco_visualiser"},{"location":"reference/coco_visualiser/#coco_assistant.coco_visualiser.get_imgid_dict","text":"Returns a dictionary with img ids as keys and img filenames as values Source code in coco_assistant/coco_visualiser.py 118 119 120 121 122 def get_imgid_dict ( ann ): \"\"\" Returns a dictionary with img ids as keys and img filenames as values \"\"\" return { item [ 1 ][ \"file_name\" ]: item [ 0 ] for item in ann . imgs . items ()}","title":"get_imgid_dict()"},{"location":"reference/utils/anchors/","text":"coco_assistant.utils.anchors \u00b6 Modified version of gen_anchors.py by Ngoc Anh Huynh ( @experiencor ) Link: https://github.com/experiencor/keras-yolo2/blob/master/gen_anchors.py In progress","title":"Utils"},{"location":"reference/utils/anchors/#coco_assistant.utils.anchors","text":"Modified version of gen_anchors.py by Ngoc Anh Huynh ( @experiencor ) Link: https://github.com/experiencor/keras-yolo2/blob/master/gen_anchors.py In progress","title":"anchors"},{"location":"reference/utils/det2seg/","text":"coco_assistant.utils.det2seg \u00b6 det2seg ( cann , output_dir , palette = True ) \u00b6 Function for converting segmentation polygons in MS-COCO object detection dataset to segmentation masks. The seg- mentation masks are stored with a colour palette that's randomly assigned based on class if specified. Change the seed if you want to change colours. Parameters: Name Type Description Default cann dict COCO annotation object required output_dir str Directory to store segmentation masks required palette bool Use palette. Defaults to True. True Raises: Type Description AssertionError Incorrect shape for colour map array AssertionError Muliple images have same image id Source code in coco_assistant/utils/det2seg.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def det2seg ( cann , output_dir , palette = True ): \"\"\" Function for converting segmentation polygons in MS-COCO object detection dataset to segmentation masks. The seg- mentation masks are stored with a colour palette that's randomly assigned based on class if specified. Change the seed if you want to change colours. Args: cann (dict): COCO annotation object output_dir (str): Directory to store segmentation masks palette (bool, optional): Use palette. Defaults to True. Raises: AssertionError: Incorrect shape for colour map array AssertionError: Muliple images have same image id \"\"\" output_dir = Path ( output_dir ) if not output_dir . is_dir (): output_dir . mkdir ( parents = True , exist_ok = True ) imids = cann . getImgIds () cats = cann . loadCats ( cann . getCatIds ()) cat_colours = { 0 : ( 0 , 0 , 0 )} # Set seed for palette colour np . random . seed ( 121 ) # Create category colourmap for c in cats : cat_colours [ c [ \"id\" ]] = ( np . random . randint ( 0 , 256 ), np . random . randint ( 0 , 256 ), np . random . randint ( 0 , 256 ), ) colour_map = np . array ( list ( cat_colours . values ())) if colour_map . shape != ( len ( cats ) + 1 , 3 ): raise AssertionError ( \"Incorrect shape of color map array\" ) for imid in tqdm ( imids ): img = cann . loadImgs ( imid ) if len ( img ) > 1 : raise AssertionError ( \"Multiple images with same id\" ) h , w = img [ 0 ][ \"height\" ], img [ 0 ][ \"width\" ] name = img [ 0 ][ \"file_name\" ] name = Path ( name ) if name . suffix . lower () != \".png\" : name = name . stem + \".png\" im = np . zeros (( h , w ), dtype = np . uint8 ) annids = cann . getAnnIds ( imgIds = [ imid ]) if not annids : # No annotations res = Image . fromarray ( im ) else : anns = cann . loadAnns ( annids ) areas = [ i [ \"area\" ] for i in anns ] area_ids = [ i for i in range ( 1 , len ( areas ) + 1 )][:: - 1 ] area_id_map = dict ( zip ( sorted ( areas ), area_ids )) area_cat_map = {} # Assumption: area of objects are unique for ann in anns : aid = area_id_map [ ann [ \"area\" ]] bMask = cann . annToMask ( ann ) aMask = bMask * aid im = np . maximum ( im , aMask ) area_cat_map [ aid ] = ann [ \"category_id\" ] # Ref: https://stackoverflow.com/questions/55949809/efficiently-replace-elements-in-array-based-on-dictionary-numpy-python/55950051#55950051 k = np . array ( list ( area_cat_map . keys ())) v = np . array ( list ( area_cat_map . values ())) mapping_ar = np . zeros ( k . max () + 1 , dtype = np . uint8 ) mapping_ar [ k ] = v res = mapping_ar [ im ] res = Image . fromarray ( res ) if palette : res . putpalette ( colour_map . astype ( np . uint8 )) res . save ( output_dir / f \" { name } \" )","title":"Det2seg"},{"location":"reference/utils/det2seg/#coco_assistant.utils.det2seg","text":"","title":"det2seg"},{"location":"reference/utils/det2seg/#coco_assistant.utils.det2seg.det2seg","text":"Function for converting segmentation polygons in MS-COCO object detection dataset to segmentation masks. The seg- mentation masks are stored with a colour palette that's randomly assigned based on class if specified. Change the seed if you want to change colours. Parameters: Name Type Description Default cann dict COCO annotation object required output_dir str Directory to store segmentation masks required palette bool Use palette. Defaults to True. True Raises: Type Description AssertionError Incorrect shape for colour map array AssertionError Muliple images have same image id Source code in coco_assistant/utils/det2seg.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 def det2seg ( cann , output_dir , palette = True ): \"\"\" Function for converting segmentation polygons in MS-COCO object detection dataset to segmentation masks. The seg- mentation masks are stored with a colour palette that's randomly assigned based on class if specified. Change the seed if you want to change colours. Args: cann (dict): COCO annotation object output_dir (str): Directory to store segmentation masks palette (bool, optional): Use palette. Defaults to True. Raises: AssertionError: Incorrect shape for colour map array AssertionError: Muliple images have same image id \"\"\" output_dir = Path ( output_dir ) if not output_dir . is_dir (): output_dir . mkdir ( parents = True , exist_ok = True ) imids = cann . getImgIds () cats = cann . loadCats ( cann . getCatIds ()) cat_colours = { 0 : ( 0 , 0 , 0 )} # Set seed for palette colour np . random . seed ( 121 ) # Create category colourmap for c in cats : cat_colours [ c [ \"id\" ]] = ( np . random . randint ( 0 , 256 ), np . random . randint ( 0 , 256 ), np . random . randint ( 0 , 256 ), ) colour_map = np . array ( list ( cat_colours . values ())) if colour_map . shape != ( len ( cats ) + 1 , 3 ): raise AssertionError ( \"Incorrect shape of color map array\" ) for imid in tqdm ( imids ): img = cann . loadImgs ( imid ) if len ( img ) > 1 : raise AssertionError ( \"Multiple images with same id\" ) h , w = img [ 0 ][ \"height\" ], img [ 0 ][ \"width\" ] name = img [ 0 ][ \"file_name\" ] name = Path ( name ) if name . suffix . lower () != \".png\" : name = name . stem + \".png\" im = np . zeros (( h , w ), dtype = np . uint8 ) annids = cann . getAnnIds ( imgIds = [ imid ]) if not annids : # No annotations res = Image . fromarray ( im ) else : anns = cann . loadAnns ( annids ) areas = [ i [ \"area\" ] for i in anns ] area_ids = [ i for i in range ( 1 , len ( areas ) + 1 )][:: - 1 ] area_id_map = dict ( zip ( sorted ( areas ), area_ids )) area_cat_map = {} # Assumption: area of objects are unique for ann in anns : aid = area_id_map [ ann [ \"area\" ]] bMask = cann . annToMask ( ann ) aMask = bMask * aid im = np . maximum ( im , aMask ) area_cat_map [ aid ] = ann [ \"category_id\" ] # Ref: https://stackoverflow.com/questions/55949809/efficiently-replace-elements-in-array-based-on-dictionary-numpy-python/55950051#55950051 k = np . array ( list ( area_cat_map . keys ())) v = np . array ( list ( area_cat_map . values ())) mapping_ar = np . zeros ( k . max () + 1 , dtype = np . uint8 ) mapping_ar [ k ] = v res = mapping_ar [ im ] res = Image . fromarray ( res ) if palette : res . putpalette ( colour_map . astype ( np . uint8 )) res . save ( output_dir / f \" { name } \" )","title":"det2seg()"},{"location":"reference/utils/misc/","text":"coco_assistant.utils.misc \u00b6","title":"Misc"},{"location":"reference/utils/misc/#coco_assistant.utils.misc","text":"","title":"misc"},{"location":"reference/utils/remapper/","text":"coco_assistant.utils.remapper \u00b6 CatRemapper \u00b6 Source code in coco_assistant/utils/remapper.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 class CatRemapper : def __init__ ( self , cat1 , cat2 ): \"\"\" Target category list needs to be remapped to reference category list. The following are the three cases to be considered: === \"Case 1\" When cat1 and cat2 overlap and cat2 has no new categories ``` cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'B'}, {'id': 2, 'name': 'C'}, {'id': 3, 'name': 'A'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] with overlap: {1:2, 2:3, 3:1} newcat : {} ``` === \"Case 2\" When cat1 and cat2 overlap & cat2 has new categories. ``` cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'B'}, {'id': 2, 'name': 'A'}, {'id': 3, 'name': 'F'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}, {'id': 4, 'name': 'F'}] with overlap: {1:2, 2:1} newcat : {3:4} ``` === \"Case 3\" When cat1 and cat2 don't overlap ``` cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'D'}, {'id': 2, 'name': 'E'}, {'id': 3, 'name': 'F'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}, {'id': 4, 'name': 'D'}, {'id': 5, 'name': 'E'}, {'id': 6, 'name': 'F'}] with overlap: {} newcat : {1:4, 2:5, 3:6} ``` Args: cat1 (list[dict]): Reference category list of dicts cat2 (list[dict]): Target category list of dicts \"\"\" self . refcat = cat1 for c in self . refcat : c [ \"name\" ] = c [ \"name\" ] . lower () self . cat1 = self . result = self . generate_id_map ( cat1 ) self . cat2 = self . generate_id_map ( cat2 ) def remap ( self , ann ): rescat , overlap_dict , newcat_dict = self . remap_cats () # Modify annotations new_ann = self . remap_annotations ( ann , overlap_dict , newcat_dict ) return rescat , new_ann def remap_cats ( self ): \"\"\" Check if the reference and target category lists overlap and remap them as necessary. Returns: tuple: - result (list[dict]): New category list - overlap_dict (dict): Mapping of overlapping categories - newcat_dict (dict): Mapping of new categories \"\"\" c1 = list ( self . cat1 . keys ()) c2 = list ( self . cat2 . keys ()) diff = sorted ( list ( set ( c2 ) - set ( c1 ))) newcat_dict = {} overlap_dict = {} res = [] if diff : # New categories for i , d in enumerate ( diff ): newcat_dict [ self . cat2 [ d ]] = len ( c1 ) + i + 1 self . result [ d ] = len ( c1 ) + i + 1 del self . cat2 [ d ] for k , v in self . result . items (): res . append ({ \"id\" : v , \"name\" : k }) for k , v in self . cat1 . items (): try : overlap_dict [ self . cat2 [ k ]] = v except KeyError : continue result = res or self . refcat return result , overlap_dict , newcat_dict def remap_annotations ( self , ann , overlaps , new_cats ): \"\"\" Remaps the annotation where overlapping category ids are mapped to reference category ids and new categories are given new ids. Args: ann (dict): Annotation being modified overlaps (dict): Mapping of overlapping categories new_cats (dict): Mapping of new categories Returns: ann: Remapped annotation \"\"\" for a in ann : cat_id = a [ \"category_id\" ] # The category is either new or exists in the reference annotation if cat_id in new_cats : a [ \"category_id\" ] = new_cats [ a [ \"category_id\" ]] else : a [ \"category_id\" ] = overlaps [ a [ \"category_id\" ]] return ann def generate_id_map ( self , cat ): \"\"\"Generate category id name mapping Args: cat (list[dict]): Category list Returns: dict: Category id name mapping \"\"\" c = [[ i [ \"name\" ] . lower (), i [ \"id\" ]] for i in cat ] keys = [ i [ 0 ] for i in c ] values = [ i [ 1 ] for i in c ] return dict ( zip ( keys , values )) __init__ ( cat1 , cat2 ) \u00b6 Target category list needs to be remapped to reference category list. The following are the three cases to be considered: Case 1 When cat1 and cat2 overlap and cat2 has no new categories cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'B'}, {'id': 2, 'name': 'C'}, {'id': 3, 'name': 'A'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] with overlap: {1:2, 2:3, 3:1} newcat : {} Case 2 When cat1 and cat2 overlap & cat2 has new categories. cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'B'}, {'id': 2, 'name': 'A'}, {'id': 3, 'name': 'F'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}, {'id': 4, 'name': 'F'}] with overlap: {1:2, 2:1} newcat : {3:4} Case 3 When cat1 and cat2 don't overlap cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'D'}, {'id': 2, 'name': 'E'}, {'id': 3, 'name': 'F'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}, {'id': 4, 'name': 'D'}, {'id': 5, 'name': 'E'}, {'id': 6, 'name': 'F'}] with overlap: {} newcat : {1:4, 2:5, 3:6} Parameters: Name Type Description Default cat1 list [ dict ] Reference category list of dicts required cat2 list [ dict ] Target category list of dicts required Source code in coco_assistant/utils/remapper.py 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def __init__ ( self , cat1 , cat2 ): \"\"\" Target category list needs to be remapped to reference category list. The following are the three cases to be considered: === \"Case 1\" When cat1 and cat2 overlap and cat2 has no new categories ``` cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'B'}, {'id': 2, 'name': 'C'}, {'id': 3, 'name': 'A'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] with overlap: {1:2, 2:3, 3:1} newcat : {} ``` === \"Case 2\" When cat1 and cat2 overlap & cat2 has new categories. ``` cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'B'}, {'id': 2, 'name': 'A'}, {'id': 3, 'name': 'F'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}, {'id': 4, 'name': 'F'}] with overlap: {1:2, 2:1} newcat : {3:4} ``` === \"Case 3\" When cat1 and cat2 don't overlap ``` cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'D'}, {'id': 2, 'name': 'E'}, {'id': 3, 'name': 'F'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}, {'id': 4, 'name': 'D'}, {'id': 5, 'name': 'E'}, {'id': 6, 'name': 'F'}] with overlap: {} newcat : {1:4, 2:5, 3:6} ``` Args: cat1 (list[dict]): Reference category list of dicts cat2 (list[dict]): Target category list of dicts \"\"\" self . refcat = cat1 for c in self . refcat : c [ \"name\" ] = c [ \"name\" ] . lower () self . cat1 = self . result = self . generate_id_map ( cat1 ) self . cat2 = self . generate_id_map ( cat2 ) generate_id_map ( cat ) \u00b6 Generate category id name mapping Parameters: Name Type Description Default cat list [ dict ] Category list required Returns: Name Type Description dict Category id name mapping Source code in coco_assistant/utils/remapper.py 163 164 165 166 167 168 169 170 171 172 173 174 175 def generate_id_map ( self , cat ): \"\"\"Generate category id name mapping Args: cat (list[dict]): Category list Returns: dict: Category id name mapping \"\"\" c = [[ i [ \"name\" ] . lower (), i [ \"id\" ]] for i in cat ] keys = [ i [ 0 ] for i in c ] values = [ i [ 1 ] for i in c ] return dict ( zip ( keys , values )) remap_annotations ( ann , overlaps , new_cats ) \u00b6 Remaps the annotation where overlapping category ids are mapped to reference category ids and new categories are given new ids. Parameters: Name Type Description Default ann dict Annotation being modified required overlaps dict Mapping of overlapping categories required new_cats dict Mapping of new categories required Returns: Name Type Description ann Remapped annotation Source code in coco_assistant/utils/remapper.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def remap_annotations ( self , ann , overlaps , new_cats ): \"\"\" Remaps the annotation where overlapping category ids are mapped to reference category ids and new categories are given new ids. Args: ann (dict): Annotation being modified overlaps (dict): Mapping of overlapping categories new_cats (dict): Mapping of new categories Returns: ann: Remapped annotation \"\"\" for a in ann : cat_id = a [ \"category_id\" ] # The category is either new or exists in the reference annotation if cat_id in new_cats : a [ \"category_id\" ] = new_cats [ a [ \"category_id\" ]] else : a [ \"category_id\" ] = overlaps [ a [ \"category_id\" ]] return ann remap_cats () \u00b6 Check if the reference and target category lists overlap and remap them as necessary. Returns: Name Type Description tuple result (list[dict]): New category list overlap_dict (dict): Mapping of overlapping categories newcat_dict (dict): Mapping of new categories Source code in coco_assistant/utils/remapper.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def remap_cats ( self ): \"\"\" Check if the reference and target category lists overlap and remap them as necessary. Returns: tuple: - result (list[dict]): New category list - overlap_dict (dict): Mapping of overlapping categories - newcat_dict (dict): Mapping of new categories \"\"\" c1 = list ( self . cat1 . keys ()) c2 = list ( self . cat2 . keys ()) diff = sorted ( list ( set ( c2 ) - set ( c1 ))) newcat_dict = {} overlap_dict = {} res = [] if diff : # New categories for i , d in enumerate ( diff ): newcat_dict [ self . cat2 [ d ]] = len ( c1 ) + i + 1 self . result [ d ] = len ( c1 ) + i + 1 del self . cat2 [ d ] for k , v in self . result . items (): res . append ({ \"id\" : v , \"name\" : k }) for k , v in self . cat1 . items (): try : overlap_dict [ self . cat2 [ k ]] = v except KeyError : continue result = res or self . refcat return result , overlap_dict , newcat_dict","title":"Remapper"},{"location":"reference/utils/remapper/#coco_assistant.utils.remapper","text":"","title":"remapper"},{"location":"reference/utils/remapper/#coco_assistant.utils.remapper.CatRemapper","text":"Source code in coco_assistant/utils/remapper.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 class CatRemapper : def __init__ ( self , cat1 , cat2 ): \"\"\" Target category list needs to be remapped to reference category list. The following are the three cases to be considered: === \"Case 1\" When cat1 and cat2 overlap and cat2 has no new categories ``` cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'B'}, {'id': 2, 'name': 'C'}, {'id': 3, 'name': 'A'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] with overlap: {1:2, 2:3, 3:1} newcat : {} ``` === \"Case 2\" When cat1 and cat2 overlap & cat2 has new categories. ``` cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'B'}, {'id': 2, 'name': 'A'}, {'id': 3, 'name': 'F'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}, {'id': 4, 'name': 'F'}] with overlap: {1:2, 2:1} newcat : {3:4} ``` === \"Case 3\" When cat1 and cat2 don't overlap ``` cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'D'}, {'id': 2, 'name': 'E'}, {'id': 3, 'name': 'F'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}, {'id': 4, 'name': 'D'}, {'id': 5, 'name': 'E'}, {'id': 6, 'name': 'F'}] with overlap: {} newcat : {1:4, 2:5, 3:6} ``` Args: cat1 (list[dict]): Reference category list of dicts cat2 (list[dict]): Target category list of dicts \"\"\" self . refcat = cat1 for c in self . refcat : c [ \"name\" ] = c [ \"name\" ] . lower () self . cat1 = self . result = self . generate_id_map ( cat1 ) self . cat2 = self . generate_id_map ( cat2 ) def remap ( self , ann ): rescat , overlap_dict , newcat_dict = self . remap_cats () # Modify annotations new_ann = self . remap_annotations ( ann , overlap_dict , newcat_dict ) return rescat , new_ann def remap_cats ( self ): \"\"\" Check if the reference and target category lists overlap and remap them as necessary. Returns: tuple: - result (list[dict]): New category list - overlap_dict (dict): Mapping of overlapping categories - newcat_dict (dict): Mapping of new categories \"\"\" c1 = list ( self . cat1 . keys ()) c2 = list ( self . cat2 . keys ()) diff = sorted ( list ( set ( c2 ) - set ( c1 ))) newcat_dict = {} overlap_dict = {} res = [] if diff : # New categories for i , d in enumerate ( diff ): newcat_dict [ self . cat2 [ d ]] = len ( c1 ) + i + 1 self . result [ d ] = len ( c1 ) + i + 1 del self . cat2 [ d ] for k , v in self . result . items (): res . append ({ \"id\" : v , \"name\" : k }) for k , v in self . cat1 . items (): try : overlap_dict [ self . cat2 [ k ]] = v except KeyError : continue result = res or self . refcat return result , overlap_dict , newcat_dict def remap_annotations ( self , ann , overlaps , new_cats ): \"\"\" Remaps the annotation where overlapping category ids are mapped to reference category ids and new categories are given new ids. Args: ann (dict): Annotation being modified overlaps (dict): Mapping of overlapping categories new_cats (dict): Mapping of new categories Returns: ann: Remapped annotation \"\"\" for a in ann : cat_id = a [ \"category_id\" ] # The category is either new or exists in the reference annotation if cat_id in new_cats : a [ \"category_id\" ] = new_cats [ a [ \"category_id\" ]] else : a [ \"category_id\" ] = overlaps [ a [ \"category_id\" ]] return ann def generate_id_map ( self , cat ): \"\"\"Generate category id name mapping Args: cat (list[dict]): Category list Returns: dict: Category id name mapping \"\"\" c = [[ i [ \"name\" ] . lower (), i [ \"id\" ]] for i in cat ] keys = [ i [ 0 ] for i in c ] values = [ i [ 1 ] for i in c ] return dict ( zip ( keys , values ))","title":"CatRemapper"},{"location":"reference/utils/remapper/#coco_assistant.utils.remapper.CatRemapper.__init__","text":"Target category list needs to be remapped to reference category list. The following are the three cases to be considered: Case 1 When cat1 and cat2 overlap and cat2 has no new categories cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'B'}, {'id': 2, 'name': 'C'}, {'id': 3, 'name': 'A'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] with overlap: {1:2, 2:3, 3:1} newcat : {} Case 2 When cat1 and cat2 overlap & cat2 has new categories. cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'B'}, {'id': 2, 'name': 'A'}, {'id': 3, 'name': 'F'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}, {'id': 4, 'name': 'F'}] with overlap: {1:2, 2:1} newcat : {3:4} Case 3 When cat1 and cat2 don't overlap cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'D'}, {'id': 2, 'name': 'E'}, {'id': 3, 'name': 'F'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}, {'id': 4, 'name': 'D'}, {'id': 5, 'name': 'E'}, {'id': 6, 'name': 'F'}] with overlap: {} newcat : {1:4, 2:5, 3:6} Parameters: Name Type Description Default cat1 list [ dict ] Reference category list of dicts required cat2 list [ dict ] Target category list of dicts required Source code in coco_assistant/utils/remapper.py 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def __init__ ( self , cat1 , cat2 ): \"\"\" Target category list needs to be remapped to reference category list. The following are the three cases to be considered: === \"Case 1\" When cat1 and cat2 overlap and cat2 has no new categories ``` cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'B'}, {'id': 2, 'name': 'C'}, {'id': 3, 'name': 'A'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] with overlap: {1:2, 2:3, 3:1} newcat : {} ``` === \"Case 2\" When cat1 and cat2 overlap & cat2 has new categories. ``` cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'B'}, {'id': 2, 'name': 'A'}, {'id': 3, 'name': 'F'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}, {'id': 4, 'name': 'F'}] with overlap: {1:2, 2:1} newcat : {3:4} ``` === \"Case 3\" When cat1 and cat2 don't overlap ``` cat1: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}] cat2: [{'id': 1, 'name': 'D'}, {'id': 2, 'name': 'E'}, {'id': 3, 'name': 'F'}] result: [{'id': 1, 'name': 'A'}, {'id': 2, 'name': 'B'}, {'id': 3, 'name': 'C'}, {'id': 4, 'name': 'D'}, {'id': 5, 'name': 'E'}, {'id': 6, 'name': 'F'}] with overlap: {} newcat : {1:4, 2:5, 3:6} ``` Args: cat1 (list[dict]): Reference category list of dicts cat2 (list[dict]): Target category list of dicts \"\"\" self . refcat = cat1 for c in self . refcat : c [ \"name\" ] = c [ \"name\" ] . lower () self . cat1 = self . result = self . generate_id_map ( cat1 ) self . cat2 = self . generate_id_map ( cat2 )","title":"__init__()"},{"location":"reference/utils/remapper/#coco_assistant.utils.remapper.CatRemapper.generate_id_map","text":"Generate category id name mapping Parameters: Name Type Description Default cat list [ dict ] Category list required Returns: Name Type Description dict Category id name mapping Source code in coco_assistant/utils/remapper.py 163 164 165 166 167 168 169 170 171 172 173 174 175 def generate_id_map ( self , cat ): \"\"\"Generate category id name mapping Args: cat (list[dict]): Category list Returns: dict: Category id name mapping \"\"\" c = [[ i [ \"name\" ] . lower (), i [ \"id\" ]] for i in cat ] keys = [ i [ 0 ] for i in c ] values = [ i [ 1 ] for i in c ] return dict ( zip ( keys , values ))","title":"generate_id_map()"},{"location":"reference/utils/remapper/#coco_assistant.utils.remapper.CatRemapper.remap_annotations","text":"Remaps the annotation where overlapping category ids are mapped to reference category ids and new categories are given new ids. Parameters: Name Type Description Default ann dict Annotation being modified required overlaps dict Mapping of overlapping categories required new_cats dict Mapping of new categories required Returns: Name Type Description ann Remapped annotation Source code in coco_assistant/utils/remapper.py 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 def remap_annotations ( self , ann , overlaps , new_cats ): \"\"\" Remaps the annotation where overlapping category ids are mapped to reference category ids and new categories are given new ids. Args: ann (dict): Annotation being modified overlaps (dict): Mapping of overlapping categories new_cats (dict): Mapping of new categories Returns: ann: Remapped annotation \"\"\" for a in ann : cat_id = a [ \"category_id\" ] # The category is either new or exists in the reference annotation if cat_id in new_cats : a [ \"category_id\" ] = new_cats [ a [ \"category_id\" ]] else : a [ \"category_id\" ] = overlaps [ a [ \"category_id\" ]] return ann","title":"remap_annotations()"},{"location":"reference/utils/remapper/#coco_assistant.utils.remapper.CatRemapper.remap_cats","text":"Check if the reference and target category lists overlap and remap them as necessary. Returns: Name Type Description tuple result (list[dict]): New category list overlap_dict (dict): Mapping of overlapping categories newcat_dict (dict): Mapping of new categories Source code in coco_assistant/utils/remapper.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 def remap_cats ( self ): \"\"\" Check if the reference and target category lists overlap and remap them as necessary. Returns: tuple: - result (list[dict]): New category list - overlap_dict (dict): Mapping of overlapping categories - newcat_dict (dict): Mapping of new categories \"\"\" c1 = list ( self . cat1 . keys ()) c2 = list ( self . cat2 . keys ()) diff = sorted ( list ( set ( c2 ) - set ( c1 ))) newcat_dict = {} overlap_dict = {} res = [] if diff : # New categories for i , d in enumerate ( diff ): newcat_dict [ self . cat2 [ d ]] = len ( c1 ) + i + 1 self . result [ d ] = len ( c1 ) + i + 1 del self . cat2 [ d ] for k , v in self . result . items (): res . append ({ \"id\" : v , \"name\" : k }) for k , v in self . cat1 . items (): try : overlap_dict [ self . cat2 [ k ]] = v except KeyError : continue result = res or self . refcat return result , overlap_dict , newcat_dict","title":"remap_cats()"}]}